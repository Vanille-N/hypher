#![allow(clippy::type_complexity)]

use std::fmt::{self, Write};
use std::fs;
use std::path::Path;

#[test]
fn generate_code() {
    let mut languages: [(&str, &str, &[&str], &str, &str, u8, u8); 35] = [
        ("Afrikaans", "af", &[], "Latn", "hyph-af.tex", 1, 2),
        ("Belarusian", "be", &[], "Cyrl", "hyph-be.tex", 2, 2),
        ("Bulgarian", "bg", &[], "Cyrl", "hyph-bg.tex", 2, 2),
        ("Catalan", "ca", &[], "Latn", "hyph-ca.tex", 2, 2),
        ("Czech", "cs", &[], "Latn", "hyph-cs-sojka.tex", 2, 2),
        ("Danish", "da", &[], "Latn", "hyph-da.tex", 2, 2),
        ("German", "de", &[], "Latn", "hyph-de-1996.tex", 2, 2),
        ("Greek", "el", &[], "Grek", "hyph-el-monoton.tex", 1, 1),
        ("English", "en", &[], "Latn", "hyph-en-us.tex", 2, 3),
        ("Spanish", "es", &[], "Latn", "hyph-es.tex", 2, 2),
        ("Estonian", "et", &[], "Latn", "hyph-et.tex", 2, 3),
        ("Finnish", "fi", &[], "Latn", "hyph-fi.tex", 2, 2),
        ("French", "fr", &[], "Latn", "hyph-fr.tex", 2, 2),
        ("Croatian", "hr", &[], "Latn", "hyph-hr.tex", 2, 2),
        ("Hungarian", "hu", &[], "Latn", "hyph-hu.tex", 2, 2),
        ("Icelandic", "is", &[], "Latn", "hyph-is.tex", 2, 2),
        ("Italian", "it", &[], "Latn", "hyph-it.tex", 2, 2),
        ("Georgian", "ka", &[], "Geor", "hyph-ka.tex", 1, 2),
        ("Kurmanji", "ku", &[], "Latn", "hyph-kmr.tex", 2, 2),
        ("Latin", "la", &[], "Latn", "hyph-la.tex", 2, 2),
        ("Lithuanian", "lt", &[], "Latn", "hyph-lt.tex", 2, 2),
        ("Mongolian", "mn", &[], "Cyrl", "hyph-mn.tex", 2, 2),
        ("Dutch", "nl", &[], "Latn", "hyph-nl.tex", 2, 2),
        ("Norwegian", "no", &["nb", "nn"], "Latn", "hyph-no.tex", 2, 2),
        ("Polish", "pl", &[], "Latn", "hyph-pl.tex", 2, 2),
        ("Portuguese", "pt", &[], "Latn", "hyph-pt.tex", 2, 3),
        ("Russian", "ru", &[], "Cyrl", "hyph-ru.tex", 2, 2),
        ("Serbian", "sr", &[], "Cyrl", "hyph-sh-cyrl.tex", 2, 2),
        ("Slovak", "sk", &[], "Latn", "hyph-sk.tex", 2, 3),
        ("Slovenian", "sl", &[], "Latn", "hyph-sl.tex", 2, 2),
        ("Albanian", "sq", &[], "Latn", "hyph-sq.tex", 2, 2),
        ("Swedish", "sv", &[], "Latn", "hyph-sv.tex", 2, 2),
        ("Turkmen", "tk", &[], "Latn", "hyph-tk.tex", 2, 2),
        ("Turkish", "tr", &[], "Latn", "hyph-tr.tex", 2, 2),
        ("Ukrainian", "uk", &[], "Cyrl", "hyph-uk.tex", 2, 2),
    ];

    languages.sort();

    // Build the tries.
    let mut fresh = true;
    for (_, iso, _, _, filename, ..) in languages {
        let source = Path::new("patterns").join(filename);
        let tex = fs::read_to_string(&source).unwrap();
        let trie = hypher::builder::build_trie(&tex);
        let path = format!("tries/{iso}.bin");
        fresh &= write_check(&path, trie);
    }

    // Build the lang.rs file.
    let mut text = String::new();
    write_lang(&mut text, &languages).unwrap();
    fresh &= write_check("src/lang.rs", text.into_bytes());

    if !fresh {
        panic!("Trie data or generated code was outdated.");
    }
}

fn write_check(path: &str, data: Vec<u8>) -> bool {
    let prev = fs::read(path).unwrap_or_default();
    fs::write(path, &data).unwrap();
    prev == data
}

fn write_lang(
    w: &mut String,
    languages: &[(&str, &str, &[&str], &str, &str, u8, u8)],
) -> fmt::Result {
    writeln!(w, "// This file is generated by tests/generate.rs")?;
    writeln!(w, "// Do not edit by hand!")?;
    writeln!(w)?;

    writeln!(w, "#[cfg(not(feature = \"dyn\"))]")?;
    writeln!(w, "use core::marker::PhantomData;")?;
    writeln!(w, "/// Not `pub`, thus not constructible.")?;
    writeln!(w, "#[cfg(not(feature = \"dyn\"))]")?;
    writeln!(w, "#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]")?;
    writeln!(w, "struct Absurd<'a>(PhantomData<&'a ()>);")?;
    writeln!(w)?;

    writeln!(w, "/// A language you can hyphenate in.")?;
    writeln!(w, "///")?;
    writeln!(w, "/// Lists for each language also the ISO 639-1 two")?;
    writeln!(w, "/// letter language code and the ISO 15924 four letter")?;
    writeln!(w, "/// script code.")?;
    writeln!(w, "#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]")?;
    writeln!(w, "#[non_exhaustive]")?;
    writeln!(w, "#[allow(private_interfaces)]")?;
    writeln!(w, "pub enum Lang<'a> {{")?;

    for &(name, iso, isos, script, ..) in languages {
        let feature = name.to_lowercase();
        write!(w, "    /// Hyphenation for _{name}._ (Code: `{iso}`, ")?;
        for code in isos {
            write!(w, "Alias: `{code}`, ")?;
        }
        writeln!(w, "Script, `{script}`, Feature: `{feature}`)")?;
        write!(w, "    ")?;
        write_cfg(w, &feature)?;
        writeln!(w, "    {name},")?;
    }

    // After the statically generated list of languages,
    // we include the dynamically loaded one.
    writeln!(w, "    /// Dynamically loaded patterns.")?;
    writeln!(w, "    #[cfg(feature = \"dyn\")]")?;
    writeln!(w, "    Dyn {{")?;
    writeln!(w, "        /// See method `bounds`.")?;
    writeln!(w, "        bounds: (usize, usize),")?;
    writeln!(w, "        /// See method `root`.")?;
    writeln!(w, "        bytes: &'a [u8],")?;
    writeln!(w, "    }},")?;
    writeln!(w, "    /// Cannot be constructed. Silences the unused lifetime warning.")?;
    writeln!(w, "    #[cfg(not(feature = \"dyn\"))]")?;
    writeln!(w, "    Absurd(Absurd<'a>),")?;

    writeln!(w, "}}")?;
    writeln!(w)?;

    writeln!(w, "impl Lang<'static> {{")?;

    // Implementation of `from_iso`.
    writeln!(w, "    /// Select a language using its ISO 639-1 code.")?;
    writeln!(w, "    pub fn from_iso(code: [u8; 2]) -> Option<Self> {{")?;
    writeln!(w, "        match &code {{")?;
    for &(name, iso, isos, ..) in languages {
        let feature = name.to_lowercase();
        write!(w, "            ")?;
        write_cfg(w, &feature)?;
        writeln!(w, r#"            b"{iso}" => Some(Self::{name}),"#)?;
        for code in isos {
            write!(w, "            ")?;
            write_cfg(w, &feature)?;
            writeln!(w, r#"            b"{code}" => Some(Self::{name}),"#)?;
        }
    }
    writeln!(w, "            _ => None,")?;
    writeln!(w, "        }}")?;
    writeln!(w, "    }}")?;
    writeln!(w, "}}")?;
    writeln!(w)?;

    writeln!(w, "impl<'a> Lang<'a> {{")?;
    // Implement dynamic loading
    writeln!(w, "    /// Dynamically load new patterns.")?;
    writeln!(w, "    #[cfg(feature = \"dyn\")]")?;
    writeln!(
        w,
        "    pub fn from_bytes(bounds: (usize, usize), bytes: &'a [u8]) -> Self {{"
    )?;
    writeln!(w, "        Self::Dyn {{ bounds, bytes }}")?;
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // Implementation of `bounds`.
    writeln!(w, "    /// The default number of chars to each side between")?;
    writeln!(w, "    /// which breaking is forbidden.")?;
    writeln!(w, "    ///")?;
    writeln!(w, "    /// This follows typographic conventions.")?;
    writeln!(w, "    pub fn bounds(self) -> (usize, usize) {{")?;
    writeln!(w, "        match self {{")?;
    for (name, .., lmin, rmin) in languages {
        let feature = name.to_lowercase();
        write!(w, "            ")?;
        write_cfg(w, &feature)?;
        writeln!(w, "            Self::{name} => ({lmin}, {rmin}),")?;
    }
    writeln!(w, "            #[cfg(feature = \"dyn\")]")?;
    writeln!(w, "            Self::Dyn {{ bounds, .. }} => bounds,")?;
    writeln!(w, "            #[cfg(not(feature = \"dyn\"))]")?;
    writeln!(w, "            Self::Absurd(_) => unreachable!(),")?;
    writeln!(w, "        }}")?;
    writeln!(w, "    }}")?;
    writeln!(w)?;

    // Implementation of `root`.
    writeln!(w, "    fn root(self) -> State<'a> {{")?;
    writeln!(w, "        match self {{")?;
    for (name, iso, ..) in languages {
        let feature = name.to_lowercase();
        write!(w, "            ")?;
        write_cfg(w, &feature)?;
        write!(w, "            Self::{name} => State::root(")?;
        writeln!(w, "include_bytes!(\"../tries/{iso}.bin\")),")?;
    }
    writeln!(w, "            #[cfg(feature = \"dyn\")]")?;
    writeln!(w, "            Self::Dyn {{ bytes, .. }} => State::root(bytes),")?;
    writeln!(w, "            #[cfg(not(feature = \"dyn\"))]")?;
    writeln!(w, "            Self::Absurd(_) => unreachable!(),")?;
    writeln!(w, "        }}")?;
    writeln!(w, "    }}")?;
    writeln!(w, "}}")
}

fn write_cfg(w: &mut String, feature: &str) -> fmt::Result {
    writeln!(w, r#"#[cfg(feature = "{feature}")]"#)
}
